// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
* @title Takachain
* @dev A smart contract for managing plastic deposits and payments
* between Pickers and Recyclers on the Avalanche testnet.
*/
contract Takachain {
// --- Data Structures ---

/**
* @dev Represents a plastic picker user.
* @param isRegistered True if the address is registered as a picker.
* @param name The name of the picker.
* @param totalDepositedWeight The total weight of plastic deposited by this picker, in grams.
* @param totalEarnings The total AVAX earned by this picker.
*/
struct Picker {
bool isRegistered;
string name;
uint256 totalDepositedWeight;
uint256 totalEarnings;
 }

/**
* @dev Represents a recycler user.
* @param isRegistered True if the address is registered as a recycler.
* @param name The name of the recycler.
* @param totalPaid The total AVAX paid by this recycler.
* @param verifiedDepositCount The number of deposits this recycler has verified.
*/
struct Recycler {
bool isRegistered;
string name;
uint256 totalPaid;
uint256 verifiedDepositCount;
}

/**
* @dev Represents a single plastic deposit.
* @param pickerAddress The address of the picker who made the deposit.
* @param plasticWeight The weight of the plastic, in grams.
* @param timestamp The time the deposit was created.
* @param isVerified True if a recycler has verified the deposit.
* @param isPaid True if a recycler has paid for the deposit.
* @param paymentAmount The amount of AVAX paid for this deposit.
* @param recyclerVerifier The address of the recycler who verified the deposit.
* @param recyclerPayer The address of the recycler who paid for the deposit.
*/
struct PlasticDeposit {
address pickerAddress;
uint256 plasticWeight;
uint256 timestamp;
bool isVerified;
bool isPaid;
uint256 paymentAmount;
address recyclerVerifier;
address recyclerPayer;
}

// --- State Variables ---

// A counter for unique deposit IDs
uint256 public nextDepositId = 0;

// Mappings to store user data
mapping(address => Picker) public pickers;
mapping(address => Recycler) public recyclers;

// Array to store all plastic deposits
PlasticDeposit[] public plasticDeposits;

// --- Events ---

event PickerRegistered(address indexed pickerAddress, string name);
event RecyclerRegistered(address indexed recyclerAddress, string name);
event RecyclerRequested(address indexed pickerAddress, uint256 depositId);
event PlasticDepositedAndVerified(uint256 indexed depositId, uint256 weight, address indexed verifier);
event PaymentMade(uint256 indexed depositId, address indexed pickerAddress, address indexed payer, uint256 amount);

// --- Modifiers ---

/**
* @dev Throws if the caller is not a registered picker.
*/
modifier onlyPicker() {
require(pickers[msg.sender].isRegistered, "Caller is not a registered picker.");
 _;
 }

/**
* @dev Throws if the caller is not a registered recycler.
*/
modifier onlyRecycler() {
require(recyclers[msg.sender].isRegistered, "Caller is not a registered recycler.");
 _;
  }

// --- Registration Functions ---

 /**
* @dev Allows a user to register as a Picker.
* @param _name The name of the picker.
*/
 function registerPicker(string memory _name) public {
 require(!pickers[msg.sender].isRegistered, "Already registered as a picker.");
 pickers[msg.sender] = Picker({
 isRegistered: true,
 name: _name,
 totalDepositedWeight: 0,
 totalEarnings: 0
 });
emit PickerRegistered(msg.sender, _name);
}

/**
* @dev Allows a user to register as a Recycler.
* @param _name The name of the recycler.
*/
function registerRecycler(string memory _name) public {
require(!recyclers[msg.sender].isRegistered, "Already registered as a recycler.");
recyclers[msg.sender] = Recycler({
isRegistered: true,
name: _name,
totalPaid: 0,
verifiedDepositCount: 0
});
emit RecyclerRegistered(msg.sender, _name);
}

// --- Picker-Specific Functions ---

/**
* @dev Creates a new pending plastic deposit request.
* @return The unique ID of the new deposit record.
*/
function requestRecycler() public onlyPicker returns (uint256) {
plasticDeposits.push(PlasticDeposit({
pickerAddress: msg.sender,
plasticWeight: 0, // Weight is set later by recycler
timestamp: block.timestamp,
isVerified: false,
isPaid: false,
paymentAmount: 0,
recyclerVerifier: address(0),
recyclerPayer: address(0)
}));
uint256 depositId = nextDepositId;
nextDepositId++;
emit RecyclerRequested(msg.sender, depositId);
return depositId;
 }

// --- Recycler-Specific Functions ---

/**
* @dev Allows a recycler to deposit and verify a plastic request.
* This combines the two original steps into a single action.
* @param _depositId The ID of the deposit to verify.
* @param _weight The weight of the plastic in grams.
*/
function depositAndVerifyPlastic(uint256 _depositId, uint256 _weight) public onlyRecycler {
require(_depositId < plasticDeposits.length, "Invalid deposit ID.");
PlasticDeposit storage deposit = plasticDeposits[_depositId];
require(!deposit.isVerified, "Deposit is already verified.");
require(_weight > 0, "Weight must be greater than zero.");

 // Update deposit details
 deposit.plasticWeight = _weight;
 deposit.isVerified = true;
 deposit.recyclerVerifier = msg.sender;

 // Update picker's total weight
 pickers[deposit.pickerAddress].totalDepositedWeight += _weight;

 // Update recycler's count of verified deposits
 recyclers[msg.sender].verifiedDepositCount++;

 emit PlasticDepositedAndVerified(_depositId, _weight, msg.sender);
 }

 /**
* @dev Allows a recycler to pay a picker for a verified deposit.
* @param _depositId The ID of the deposit to pay for.
*/
 function makePayment(uint256 _depositId) public payable onlyRecycler {
 require(_depositId < plasticDeposits.length, "Invalid deposit ID.");
 PlasticDeposit storage deposit = plasticDeposits[_depositId];
 require(deposit.isVerified, "Deposit has not been verified yet.");
 require(!deposit.isPaid, "Payment has already been made for this deposit.");
 require(msg.value > 0, "Payment amount must be greater than zero.");

 // Update deposit details
 deposit.isPaid = true;
deposit.paymentAmount = msg.value;
 deposit.recyclerPayer = msg.sender;

// Update picker's total earnings
pickers[deposit.pickerAddress].totalEarnings += msg.value;

// Update recycler's total paid amount
recyclers[msg.sender].totalPaid += msg.value;

 // Transfer funds to the picker
 (bool success, ) = deposit.pickerAddress.call{value: msg.value}("");
 require(success, "Failed to send AVAX to picker.");

 emit PaymentMade(_depositId, deposit.pickerAddress, msg.sender, msg.value);
 }

 // --- Getter Functions ---

 /**
* @dev Returns all details for a given deposit.
* @param _depositId The ID of the deposit.
*/
 function getDeposit(uint256 _depositId) public view returns (PlasticDeposit memory) {
 require(_depositId < plasticDeposits.length, "Invalid deposit ID.");
 return plasticDeposits[_depositId];
 }

 /**
* @dev Returns the total number of deposits.
*/
function getTotalDeposits() public view returns (uint256) {
 return plasticDeposits.length;
 }
}
